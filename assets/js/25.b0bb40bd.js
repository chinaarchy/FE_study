(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{376:function(v,_,l){"use strict";l.r(_);var t=l(9),n=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"虚拟dom"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[v._v("#")]),v._v(" 虚拟DOM")]),v._v(" "),l("p",[v._v("通过变化侦测可以识别到数据的修改，之后通知外界进行视图的更改。使用虚拟DOM本质上就是通过运算较快的JS代替DOM操作，提升运行的速度。\nVue中通过编译将模版转换成渲染函数（rander），执行渲染函数生成虚拟节点树，再通过虚拟节点树渲染视图。")]),v._v(" "),l("p",[v._v("在vnode变化后，通过patch进行比较，以最小的代价修改节点。vnode是对各种节点的抽象类，即节点描述对象。vnode的类型有以下几种：")]),v._v(" "),l("ol",[l("li",[v._v("注释节点")]),v._v(" "),l("li",[v._v("文本节点")]),v._v(" "),l("li",[v._v("克隆节点")]),v._v(" "),l("li",[v._v("组件节点")]),v._v(" "),l("li",[v._v("元素节点")]),v._v(" "),l("li",[v._v("函数式节点")])]),v._v(" "),l("h3",{attrs:{id:"patch"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[v._v("#")]),v._v(" patch")]),v._v(" "),l("p",[v._v("patch对现有DOM的操作主要为以下3种：")]),v._v(" "),l("ol",[l("li",[v._v("创建新增节点\n"),l("ul",[l("li",[v._v("首次渲染时")]),v._v(" "),l("li",[v._v("vnode与oldVnode完全不是一个节点时")])])]),v._v(" "),l("li",[v._v("删除已经废弃的节点\n"),l("ul",[l("li",[v._v("vnode与oldVnode完全不是一个节点时")])])]),v._v(" "),l("li",[v._v("修改需要更新的节点\n"),l("ul",[l("li",[v._v("新旧vnode是同一个时")])])])]),v._v(" "),l("h4",{attrs:{id:"更新节点的过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#更新节点的过程"}},[v._v("#")]),v._v(" 更新节点的过程")]),v._v(" "),l("ol",[l("li",[v._v("判断节点的类型")]),v._v(" "),l("li",[v._v("如果节点相同或者为静态节点，不做处理")]),v._v(" "),l("li",[v._v("如果节点为文本节点，直接修改内容")]),v._v(" "),l("li",[v._v("如果新旧节点都包含子元素，更新子元素")]),v._v(" "),l("li",[v._v("如果新节点包含，旧节点不包含，清空旧节点数据，渲染新节点数据")]),v._v(" "),l("li",[v._v("如果旧节点包含，新节点不包含，清空节点")])]),v._v(" "),l("p",[v._v("其中更新子元素的过程比较复杂，需要单独拿出来说。对于子节点的更新策略也包含新增、更新和删除操作。")]),v._v(" "),l("ul",[l("li",[v._v("新增：迭代比较新旧数组，如果节点在旧数组中不存在，就添加新节点到未处理节点的前面。")]),v._v(" "),l("li",[v._v("更新：如果发现节点的位置发生了变化，就将旧数组中的节点移到未处理数组的前面。")]),v._v(" "),l("li",[v._v("删除：比较完所有的节点之后，舍弃到之前的数组节点。")])]),v._v(" "),l("h4",{attrs:{id:"优化策略"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#优化策略"}},[v._v("#")]),v._v(" 优化策略")]),v._v(" "),l("p",[v._v("通过分析DOM操作的习惯，移位操作较少，Vue中使用了几种方法对迭代进行优化。在介绍优化策略之前需要先介绍几个指针。")]),v._v(" "),l("ul",[l("li",[v._v("newStartIndex： 新节点列表中未处理的节点的第一个的位置指针")]),v._v(" "),l("li",[v._v("newEndIndex： 新节点列表中未处理的节点的最后一个的位置指针")]),v._v(" "),l("li",[v._v("oldStartIndex： 旧节点列表中未处理的节点的第一个的位置指针")]),v._v(" "),l("li",[v._v("oldEndIndex： 旧节点列表中未处理的节点的最后一个的位置指针")])]),v._v(" "),l("p",[v._v("相对应的优化策略也有以下几种：")]),v._v(" "),l("ol",[l("li",[v._v("首先比较newStartIndex和oldStartIndex，相同就同时向后移动一个指针")]),v._v(" "),l("li",[v._v("首先比较newEndIndex和oldEndIndex，相同就同时向前移动一个指针")]),v._v(" "),l("li",[v._v("首先比较newStartIndex和oldEndIndex，把oldEndIndex移动到对应位置，并做指针的移动")]),v._v(" "),l("li",[v._v("首先比较newEndIndex和oldStartIndex，移动旧节点到对应位置，做指针的移动")])]),v._v(" "),l("p",[v._v("这样的优化策略是移动两边向中间移动的一个流程，减少了剩余节点的数量，降低了迭代的运算量。\n之后不断根据之前迭代的思想不断向中间移动指针，知道新旧两个指针的其中一个迭代完。如果旧指针先结束，表示还有剩余的新增节点，统一进行新增的操作。\n如果新指针先结束，旧指针剩下的项都是需要移除的节点。大大降低了运算量。")])])}),[],!1,null,null,null);_.default=n.exports}}]);