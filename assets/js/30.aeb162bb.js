(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{379:function(a,t,r){"use strict";r.r(t);var e=r(9),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"js内存策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js内存策略"}},[a._v("#")]),a._v(" JS内存策略")]),a._v(" "),r("p",[a._v("V8的内存限制，导致Node通过JavaScript只能使用部分内存（64位系统1.4G，32位系统0.7G）\n对于内存的限制主要来自两方面的原因，首先是浏览器场景下，不太可能遇到大内存的情况，同时也是为了快速的垃圾回收，\n按照官方的说法，垃圾回收1.5G堆内存，V8做一次小的垃圾回收需要50毫秒以上。")]),a._v(" "),r("h3",{attrs:{id:"v8垃圾回收机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制"}},[a._v("#")]),a._v(" V8垃圾回收机制")]),a._v(" "),r("p",[a._v("V8的垃圾回收策略是分代式垃圾回收策略。分为新生代和老生代。")]),a._v(" "),r("h4",{attrs:{id:"新生代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[a._v("#")]),a._v(" 新生代")]),a._v(" "),r("p",[a._v("新生代采用Scavenge算法，具体实现为Cheney算法，为一种采用复制方式实现的垃圾回收算法。\n其思想是将新生代空间分为两部分，分别为From和To，数据首先存储在From空间中，当From空间满了之后，将数据拷贝到To空间，并进行判断，完成垃圾回收。并将新的空间命名为From，之前的空间为To。\n算法牺牲空间来换取时间，故不能大规模的应用到所有垃圾回收中。")]),a._v(" "),r("h3",{attrs:{id:"老生代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#老生代"}},[a._v("#")]),a._v(" 老生代")]),a._v(" "),r("p",[a._v("当一个数据经过多次复制依然存活的时候，将其晋升，复制到老生代。\n晋升的条件有两个：")]),a._v(" "),r("ol",[r("li",[a._v("当数据经过了一个新生代的复制后依然存在，并且又要从From复制到To的时候，将其晋升为老生代。")]),a._v(" "),r("li",[a._v("当从From复制到To的过程中，To的占比超过了25%，直接将新数据晋升。")])]),a._v(" "),r("p",[a._v("同时老生代的数据回收策略也需要进行更改，采用Mark-Sweep和Mark-Compact相结合的方法。")]),a._v(" "),r("p",[a._v("Mark-Sweep算法与Scavenge相似，不过其遍历数据对依然存活的数据进行标记，在之后的Sweep阶段，清除未被标记的数据。\n但是经过Sweep过程后，可能存在内存不连续，无法更高效的利用数据。")]),a._v(" "),r("p",[a._v("基于以上引入Mark-Compact，将存活的数据与进行移动，将所有存活的数据移动到一边，之后清空边界之外的数据。")]),a._v(" "),r("p",[a._v("但是Mark-Compact算法速度较慢，V8主要采用Mark-Sweep算法，只在内存大小不够的时候使用Mark-Compact。")])])}),[],!1,null,null,null);t.default=v.exports}}]);